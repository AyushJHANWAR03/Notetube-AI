"""
Chat API routes for AI-powered conversations about video content.

Supports Server-Sent Events (SSE) for streaming responses.
"""
from typing import List
from uuid import UUID

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from app.core.database import get_db
from app.schemas.chat import (
    ChatMessageCreate,
    ChatMessageResponse,
    ChatHistoryResponse,
)
from app.schemas.user import User
from app.services.chat_service import ChatService, ChatServiceError
from app.api.dependencies.auth import get_current_user
from app.models.video import Video
from app.models.notes import Notes
from app.models.chat import ChatMessage


router = APIRouter(prefix="/api/videos", tags=["chat"])


async def get_video_with_notes(video_id: UUID, user_id: UUID, db: AsyncSession):
    """Helper to get video and notes, verifying ownership."""
    # Get video
    result = await db.execute(
        select(Video).where(Video.id == video_id, Video.user_id == user_id)
    )
    video = result.scalar_one_or_none()

    if not video:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Video not found"
        )

    # Get notes
    result = await db.execute(
        select(Notes).where(Notes.video_id == video_id)
    )
    notes = result.scalar_one_or_none()

    return video, notes


@router.post("/{video_id}/chat/stream")
async def stream_chat_response(
    video_id: UUID,
    request: ChatMessageCreate,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Send a chat message and receive a streaming SSE response.

    The response streams tokens as they are generated by the AI.
    Uses gpt-3.5-turbo for cost efficiency.

    - Requires authentication
    - User must own the video
    - Returns Server-Sent Events stream
    """
    video, notes = await get_video_with_notes(video_id, current_user.id, db)

    if not notes:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Video has no notes - please process the video first"
        )

    chat_service = ChatService()

    # Build context from notes
    context = chat_service.build_context(notes)

    # Convert history to expected format
    history = [{"role": m.role, "content": m.content} for m in request.history]

    async def generate_stream():
        """Generator that yields SSE events."""
        full_response = ""

        try:
            # Stream tokens from OpenAI
            async for token in chat_service.stream_response(
                message=request.message,
                context=context,
                history=history
            ):
                full_response += token
                # SSE format: data: <content>\n\n
                yield f"data: {token}\n\n"

            # After streaming completes, save both messages to DB
            # Save user message
            user_msg = ChatMessage(
                video_id=video_id,
                user_id=current_user.id,
                role="user",
                message_type="chat",
                content=request.message
            )
            db.add(user_msg)

            # Save assistant response
            assistant_msg = ChatMessage(
                video_id=video_id,
                user_id=current_user.id,
                role="assistant",
                message_type="chat",
                content=full_response
            )
            db.add(assistant_msg)
            await db.commit()

            # Generate follow-up prompts
            try:
                followups = chat_service.generate_followup_prompts(
                    user_question=request.message,
                    assistant_answer=full_response
                )
                # Send follow-ups as JSON event
                import json
                yield f"data: [FOLLOWUPS]{json.dumps(followups)}\n\n"
            except Exception as e:
                print(f"[Chat] Error generating followups: {e}")

            # Send done event
            yield "data: [DONE]\n\n"

        except Exception as e:
            yield f"data: [ERROR] {str(e)}\n\n"

    return StreamingResponse(
        generate_stream(),
        media_type="text/event-stream",
        headers={
            "Cache-Control": "no-cache",
            "Connection": "keep-alive",
            "X-Accel-Buffering": "no"  # Disable nginx buffering
        }
    )


@router.get("/{video_id}/chat/history", response_model=ChatHistoryResponse)
async def get_chat_history(
    video_id: UUID,
    limit: int = 50,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
) -> ChatHistoryResponse:
    """
    Get chat history for a video.

    - Requires authentication
    - User must own the video
    - Returns messages sorted by created_at (oldest first)
    - Limited to last 50 messages by default
    """
    video, _ = await get_video_with_notes(video_id, current_user.id, db)

    # Get chat messages
    result = await db.execute(
        select(ChatMessage)
        .where(ChatMessage.video_id == video_id, ChatMessage.user_id == current_user.id)
        .order_by(ChatMessage.created_at.desc())
        .limit(limit)
    )
    messages = result.scalars().all()

    # Reverse to get oldest first
    messages = list(reversed(messages))

    return ChatHistoryResponse(
        messages=[ChatMessageResponse.model_validate(m) for m in messages],
        total=len(messages)
    )


@router.delete("/{video_id}/chat/history", status_code=status.HTTP_204_NO_CONTENT)
async def clear_chat_history(
    video_id: UUID,
    current_user: User = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Clear all chat history for a video.

    - Requires authentication
    - User must own the video
    """
    video, _ = await get_video_with_notes(video_id, current_user.id, db)

    # Delete all messages for this video
    from sqlalchemy import delete
    await db.execute(
        delete(ChatMessage).where(
            ChatMessage.video_id == video_id,
            ChatMessage.user_id == current_user.id
        )
    )
    await db.commit()
